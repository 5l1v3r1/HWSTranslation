# Arrays

Os *arrays* permitem agrupar vários valores em uma única coleção e, depois, acessar esses valores por sua posição na coleção. O Swift usa a inferência de tipos para descobrir que tipo de dados o *array* contém, assim:

    var evenNumbers = [2, 4, 6, 8]
    var songs = ["Shake it Off", "You Belong with Me", "Back to December"]

Como você pode ver, a Swift usa colchetes para marcar o início e o fim de um *array*, e cada item do *array* é separado por uma vírgula.

Quando se trata de ler itens de um *array*, há um pegadinha: Swift começa a contar a partir de 0. Isso significa que o primeiro item é 0, o segundo item é 1, o terceiro é 2 e assim por diante. Tente colocar isso no seu playground:

    var songs = ["Shake it Off", "You Belong with Me", "Back to December"]
    songs[0]
    songs[1]
    songs[2]

Isso irá imprimir "Shake it Off", "You Belong with Me", e "Back to December" no painel de resultados.

A posição de um item no *array* é chamada de índice, e você pode ler qualquer posição do *array* apenas usando este índice. No entanto, você precisa ter cuidado: nosso *array* possui três índices, o que significa que os índices 0, 1 e 2. Mas se tentarmos ler `songs[3]` o seu *playground* vai parar de funcionar – e se tentar num aplicativo real ele irá parar!

Porque você criou um *array* passando três *strings*, Swift sabe que se trata de um *array* de *strings*. Você pode confirmar isso usando um comando especial no *playground* que irá imprimir o tipo de dados de qualquer variável, assim:

    var songs = ["Shake it Off", "You Belong with Me", "Back to December"]
    type(of: songs)

Isso irá imprimir `Array<String>.Type` no painel de resultados, informando que Swift considera que `songs` é um *array* de *strings*.

Digamos que você errou, e acidentalmente colocou um número no final do *array*. Tente isto e veja o que é informado no painel de resultados:

    var songs = ["Shake it Off", "You Belong with Me", "Back to December", 3]
    type(of: songs)

Desta vez você verá um erro. O erro não é porque a Swift não consegue lidar com *arrays* com tipos de dados diferentes como este – já vou mostrar como fazer isso em instantes! – mas porque a linguagem Swift está lhe ajudando. A mensagem de erro é, “heterogenous collection literal could only be inferred to '[Any]'; add explicit type annotation if this is intentional.” Ou, em português claro, “o *array* informado possui diferentes tipos de dados – se você realmente deseja este comportamento, por favor seja explícito.”

Segurança de tipos é importante, e apesar de ser legal que em Swift nós possamos criar *arrays* que armazenam qualquer tipo de dados este caso específico foi um erro. Felizmente, já disse que podemos usar anotações de tipo para especificar exatamente que tipo de dados desejamos armazenar em uma *array*. Para especificar o tipo de um *array*, escreva o tipo de dados que você deseja armazenar com colchetes ao redor, assim:

    var songs: [String] = ["Shake it Off", "You Belong with Me", "Back to December", 3]

Agora que dissemos ao Swift que queremos armazenar apenas strings no array, ele sempre se recusará a executar o código porque 3 não é uma string.

Se você realmente quer que o array armazene qualquer tipo de dado, use o tipo especial de dados `Any`, como abaixo:

    var songs: [Any] = ["Shake it Off", "You Belong with Me", "Back to December", 3]


## Creating arrays

If you make an array using the syntax shown above, Swift creates the array and fills it with the values we specified. Things aren't quite so straightforward if you want to create the array then fill it later – this syntax doesn't work:

    var songs: [String]
    songs[0] = "Shake it Off"

The reason is one that will seem needlessly pedantic at first, but has deep underlying performance implications so I'm afraid you're just stuck with it. Put simply, writing `var songs: [String]` tells Swift "the `songs` variable will hold an array of strings," but *it doesn't actually create that array*. It doesn't allocate any RAM, or do any of the work to actually create a Swift array. It just says that at some point there will be an array, and it will hold strings.

There are a few ways to express this correctly, and the one that probably makes most sense at this time is this:

    var songs: [String] = []

That uses a type annotation to make it clear we want an array of strings, and it assigns an empty array (that's the `[]` part) to it.

You'll also commonly see this construct:

    var songs = [String]()

That means the same thing: the `()` tells Swift we want to create the array in question, which is then assigned to `songs` using type inference. This option is two characters shorter, so it's no surprise programmers prefer it!


## Array operators

You can use a limited set of operators on arrays. For example, you can merge two arrays by using the + operator, like this:

    var songs = ["Shake it Off", "You Belong with Me", "Love Story"]
    var songs2 = ["Today was a Fairytale", "Welcome to New York", "Fifteen"]
    var both = songs + songs2

You can also use += to add and assign, like this:

    both += ["Everything has Changed"]