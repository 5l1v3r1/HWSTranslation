# Tipuri de Date

Există o mulțime de genuri de date, iar Swift le tratează pe toate in mod individual. Deja am văzut unul dintre cele mai importante tipuri când am alocat niște text unei variabile, dar în Swift se numește `String` – literalmente un șir de caractere.
//---
There are lots of kinds of data, and Swift handles them all individually. You already saw one of the most important types when you assigned some text to a variable, but in Swift this is called a `String` – literally a string of characters.
//---

Șirurile pot fi lungi (de ex. șiruri de un milion de litere), scurte (de ex. șiruri de 10 litere) sau chiar și goale (fără litere), nu contează: toate sunt șiruri din punctul de vedere al lui Swift, și toate funcționează la fel. Swift știe că `name` ar trebui să conțină un șir deoarece i-am atribuit un șir când am creat-o: "Tim McGraw". Dacă am rescrie codul astfel nu ar mai funcționa:
//---
Strings can be long (e.g. a million letters or more), short (e.g. 10 letters) or even empty (no letters), it doesn't matter: they are all strings in Swift's eyes, and all work the same. Swift knows that `name` should hold a string because you assign a string to it when you create it: "Tim McGraw". If you were to rewrite your code to this it would stop working:
//---

    var name
    name = "Tim McGraw"

De data asta Xcode ne va arăta un mesaj de eroare care nu prea are sens încă: "Type annotation missing in pattern". Ce vrea să spună este "Nu pot să îmi dau seama ce tip de date este `name` deoarece nu îmi dai destule informații".
//---
This time Xcode will give you an error message that won't make much sense just yet: "Type annotation missing in pattern". What it means is, "I can't figure out what data type `name` is because you aren't giving me enough information."
//---

În acest punct avem două opțiuni: fie creăm o variabilă și îi dăm o valoare inițială într-un singur rând, fie folosim ceea ce se numește "type annotation", atunci când îi spunem lui Swift ce tip de date va conține variabila mai târziu, chiar dacă nu îi atribuim o valoare chiar acum. 
//---
At this point you have two options: either create your variable and give it an initial value on one line of code, or use what's called a type annotation, which is where you tell Swift what data type the variable will hold later on, even though you aren't giving it a value right now.
//---

Deja am văzut cum arată prima opțiune, așa că ne vom concentra pe a doua: type annotations. Știm că `name` va fi un șir, putem scrie asta în Swift folosind două puncte si apoi `String`, astfel:
//---
You've already seen how the first option looks, so let's look at the second: type annotations. We know that `name` is going to be a string, so we can tell Swift that by writing a colon then `String`, like this:
//---

    var name: String
    name = "Tim McGraw"

În proiectele reale – spre deosebiere de playground-uri – asta merge destul de bine deoarece Swift știe ce tip de date va conține `name` în viitor. Playground-urile sunt un caz mai special, deci vom vedea o eroare.
//---
In real app projects – as opposed to playgrounds – that works just fine, because Swift knows what type of data `name` will hold in the future. Playgrounds are a slightly special case, so you’ll still get an error in the playground.
//---

**Notă:** unor persoane le place să adauge un spațiu înainte si după două puncte, astfel `var name : String`, dar *greșesc* și ar fi bine să încercăm să nu mentionăm greșala într-o companie politicoasă.
//---
**Note:** some people like to put a space before and after the colon, making `var name : String`, but they are *wrong* and you should try to avoid mentioning their wrongness in polite company.
//---

Morala este că Swift mereu vrea să știe ce tip de date va conține fiecare variabilă sau constantă. Mereu. Nu putem scăpa de asta, și asta e un lucru bun pentru că oferă ceea ce se numește "type safety" – dacă spunem "asta va conține un șir" iar apoi, mai târziu, punem un iepure acolo, Swift va refuza.
//---
The lesson here is that Swift always wants to know what type of data every variable or constant will hold. Always. You can't escape it, and that's a good thing because it provides something called type safety – if you say "this will hold a string" then later try and put a rabbit in there, Swift will refuse.
//---

Putem încerca asta acum introducând un alt tip de date important numit **Int**, care este o prescurtare a cuvântului "integer". Int-urile sunt numere întregi cum ar fi 3, 30, 300, sau -16777216. De exemplu:
//---
We can try this out now by introducing another important data type, called **Int**, which is short for "integer." Integers are round numbers like 3, 30, 300, or -16777216. For example:
//---

    var name: String
    name = "Tim McGraw"

    var age: Int
    age = 25

Aici am declarat o variabilă de tip șir și una de tip întreg. De observat este faptul că și `String` și `Int` încep cu majusculă, spre deosebire de `name` și `age` – aceasta este convenția standard de a coda în Swift. O convenție de codare este ceva care nu contează pentru Swift în sine (putem să alegem și să scriem ce nume vrem!) dar contează pentru ceilalți dezvoltatori. În cazul de mai sus, tipurile de date încep cu majusculă, în timp ce variabilele și constantele nu.
//---
That declares one variable to be a string and one to be an integer. Note how both `String` and `Int` have capital letters at the start, whereas `name` and `age` do not – this is the standard coding convention in Swift. A coding convention is something that doesn't matter to Swift (you can write your names how you like!) but does matter to other developers. In this case, data types start with a capital letter, whereas variables and constants do not.
//---

Acum că avem variabile de două tipuri diferite, putem vedea type safety în acțiune. Încearcă să scrii:
//---
Now that we have variables of two different types, you can see type safety in action. Try writing this:
//---

    name = 25
    age = "Tim McGraw"

În codul de mai sus încercăm să punem un întreg într-o variabilă de tip șir și un șir într-o variabilă de tip întreg – și, din fericire, Xcode va arunca erori. Ai putea crede că este cam exagerat dar, de fapt, e chiar de ajutor: faci o promisiune că o variabilă va conține un anumit tip de date, iar Xcode îți impune asta pe tot parcursul programului.
//---
In that code, you're trying to put an integer into a string variable, and a string into an integer variable – and, thankfully, Xcode will throw up errors. You might think this is pedantic, but it's actually quite helpful: you make a promise that a variable will hold one particular type of data, and Xcode will enforce that throughout your work.
//---

**Înainte să trecem mai departe, te rog să ștergi cele două linii de cod care cauzează eroarea, altfel nimic din playground nu va mai funcționa de aici încolo!**
//---
**Before you go on, please delete those two lines of code causing the error, otherwise nothing in your playground will work going forward!**
//---


## Float și Double

Hai să aruncăm o privire la alte două tipuri de date numite `Float` și `Double`. Acestea sunt modul lui Swift de a stoca numere cu o componentă fractorială, cum ar fi 3,1, 3,141, 3,1415926, și -16777216,5. Există două tipuri de date pentru a face acest lucru deoarece avem posibilitatea de a alege cât de multă acuratețe dorim, dar în majoritatea cazurilor nu contează așa că recomandarea oficială Apple este să folosim întotdeauna `Double` pentru că are cea mai mare acuratețe.
//---
Let's look at two more data types, called `Float` and `Double`. This is Swift's way of storing numbers with a fractional component, such as 3.1, 3.141, 3.1415926, and -16777216.5. There are two data types for this because you get to choose how much accuracy you want, but most of the time it doesn't matter so the official Apple recommendation is always to use `Double` because it has the highest accuracy.
//---

Încearcă să scrii asta în playground:
//---
Try putting this into your playground:
//---

    var latitude: Double
    latitude = 36.166667

    var longitude: Float
    longitude = -86.783333

Putem vedea ambele numere apărând în partea dreaptă, dar dacă ne uităm cu atenție putem observa că există o mică discrepanță. Am spus că `longitude` ar trebui să fie egal cu -86.783333, dar în panoul de rezultate va apărea -86.78333 – îi lipsește un 3 de la coadă. Am putea spune "ce mai contează un 0.000003 printre prieteni?" dar asta demonstrează ce am vrut să spun mai sus când m-am referit la acuratețe.
//---
You can see both numbers appear on the right, but look carefully because there's a tiny discrepancy. We said that `longitude` should be equal to -86.783333, but in the results pane you'll see -86.78333 – it's missing one last 3 on the end. Now, you might well say, "what does 0.000003 matter among friends?" but this is ably demonstrating what I was saying about accuracy.
//---

Pentru că playground-ul se actualizează în timp ce scriem, putem experimenta pentru a vedea exact cum diferă `Float` de `Double`. Încearcă să schimbi codul cu acesta:
//---
Because these playgrounds update as you type, we can try things out so you can see exactly how `Float` and `Double` differ. Try changing the code to be this:
//---

    var longitude: Float
    longitude = -86.783333
    longitude = -186.783333
    longitude = -1286.783333
    longitude = -12386.783333
    longitude = -123486.783333
    longitude = -1234586.783333

Aici adăugăm din ce în ce mai multe cifre înainte de virgulă în timp ce menținem același număr ce cifre după virgulă. Dar dacă aruncăm o privire la panoul de rezultate putem observa că în timp ce adăugăm cifre înainte de virgulă, Swift șterge cifre de după virgulă. Asta se întâmlpă pentru că există un spațiu limitat în care putem să ne stocăm numărul, așa că Swift prioretizează stocarea parții mai importante – să avem o eroare de 1.000.000 este imens, în timp ce o eroare de 0,000003 nu prea înseamnă nimic.
//---
That's adding increasing numbers before the decimal point, while keeping the same amount of numbers after. But if you look in the results pane you'll notice that as you add more numbers before the point, Swift is removing numbers after. This is because it has limited space in which to store your number, so it's storing the most important part first – being off by 1,000,000 is a big thing, whereas being off by 0.000003 is less so.
//---

![În Swift un Float are o capacitate mult mai mică decât un Double, așa că e bine să folosim Double pe cât posibil.](0-4.png)
//---
![In Swift a Float holds much less data than a Double, so you should use Double where possible.](0-4.png)
//---

Acum hai să schimbăm `Float`-ul într-un `Double` și vom vedea că Swift printează numărul corect de fiecare dată:
//---
Now try changing the `Float` to be a `Double` and you'll see Swift prints the correct number out every time:
//---

    var longitude: Double

Din nou, asta se întâmplă deoarece un `Double` are acuratețea de două ori mai mare decât un `Float`, deci nu trebuie să taie din număr pentru a încăpea. `Double`-urile au totuși limite – dacă am încerca cu un număr masiv cum ar fi 123456789,123456789 vom observa că este rotunjit la 123456789,12345679.
//---
This is because, again, `Double` has twice the accuracy of `Float` so it doesn't need to cut your number to fit. Doubles still have limits, though – if you were to try a massive number like 123456789.123456789 you would see it gets cut down to 123456789.12345679.
//---


## Boolean

Swift has a built-in data type that can store whether a value is true or false, called a `Bool`, short for Boolean. Bools don't have space for "maybe" or "perhaps", only absolutes: true or false. For example:

    var stayOutTooLate: Bool
    stayOutTooLate = true

    var nothingInBrain: Bool
    nothingInBrain = true

    var missABeat: Bool
    missABeat = false


## Using type annotations wisely

As you've learned, there are two ways to tell Swift what type of data a variable holds: assign a value when you create the variable, or use a type annotation. If you have a choice, the first is always preferable because it's clearer. For example:

    var name = "Tim McGraw"

…is preferred to:

    var name: String
    name = "Tim McGraw"

This applies to all data types. For example:

    var age = 25
    var longitude = -86.783333
    var nothingInBrain = true

This technique is called *type inference*, because Swift can infer what data type should be used for a variable by looking at the type of data you want to put in there. When it comes to numbers like -86.783333, Swift will always infer a `Double` rather than a `Float`.

For the sake of completeness, I should add that it's possible to specify a data type and provide a value at the same time, like this:

    var name: String = "Tim McGraw"

