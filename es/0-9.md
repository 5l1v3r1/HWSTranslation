# Ciclos

~~Computers are great at doing boring tasks billions of times in the time it took you to read this sentence. When it comes to repeating tasks in code, you can either copy and paste your code multiple times, or you can use *loops* – simple programming constructs that repeat a block of code for as long as a condition is true.~~

Las computadoras son excelentes para realizar tareas aburridas billiones de veces en el tiempo tomaste leer esta sentencia. Cuando necesitas repetir tareas en tu programa, puedes copiar y pegar múltiples tiempos, o utilizas *ciclos* – simples constructos de programación que repiten un bloque de código para siempre y cuando una condición queda cierta.

~~To demonstrate this, I want to introduce you to a special debugging function called `print()`: you give it some text to print, and it will print it. If you're running in a playground like we are, you'll see your text appear in the results window. If you're running a real app in Xcode, you'll see your text appear in Xcode's log window. Either way, `print()` is a great way to get a sneak peek at the contents of a variable.~~

Para demostrar este, te presento una función especial de depuración de errores llamado `print()`: das algún texto para imprimir, y lo imprimirá. Si estás utilizando un playground como nosotros, verás que tu texto aparece en la ventana de resultados de Xcode. En cualquier caso, `print()` es un buen modo de sacar "sneak peek" a lo que está contenido en un variable.

~~Take a look at this code:~~

Considérate este código:

    print("1 x 10 is \(1 * 10)")
    print("2 x 10 is \(2 * 10)")
    print("3 x 10 is \(3 * 10)")
    print("4 x 10 is \(4 * 10)")
    print("5 x 10 is \(5 * 10)")
    print("6 x 10 is \(6 * 10)")
    print("7 x 10 is \(7 * 10)")
    print("8 x 10 is \(8 * 10)")
    print("9 x 10 is \(9 * 10)")
    print("10 x 10 is \(10 * 10)")

~~When it has finished running, you'll have the 10 times table in your playground results pane. But it's hardly efficient code, and in fact a much cleaner way is to loop over a range of numbers using what's called the closed range operator, which is three periods in a row: `...`~~

Cuando el código termina corriendo, verás la tabla de multiplicación de 10 el panel de resultados del playground. Pero este código es menos eficiente, y en realidad una manera más limpia es ciclar sobre un serie de números utilizando que está llamado el operador de serie cerrado, cúal es tres períodos en una fila: `...`

~~Using the closed range operator, we could re-write that whole thing in three lines:~~

Utilizando este operador, podemos escribir todas las sentencias de `print` desde antes en tres líneas:

    for i in 1...10 {
        print("\(i) x 10 is \(i * 10)")
    }

~~The results pane just shows "(10 times)" for our loop, meaning that the loop was run 10 times. If you want to know what the loop actually did, click the square immediately to the right of “(10 times). You'll see a box saying "10 x 10 is 100" appear inside your code, and if you right-click on that you should see the option “Value History”. Click on that now, and you should see the picture below:~~

El panel de resultados solo muestra "(10 veces)" para nuestro ciclo, lo que significa que el ciclo se ejecutó 10 veces. Si desea saber lo que realmente hizo el ciclo, haz clic en el cuadro inmediatamente a la derecha de "(10 veces)". Aparecerá una opción que dice "10 x 10 es 100" en su código, y si haces clic con el botón derecho, verás una opción de "Value History". Haz clic en esto ahora, y verás la foto a continuación:

~~![When a Swift playground runs through a loop it only shows how many times that loop was run. If you want to inspect the values more closely, click the box in the results area.]~~

![Cuando un playground de Swift ejecuta un ciclo solo muestrate cuantos veces que fue utilizado. Si quieres evaluar los valores más, haz clic en el cuadro del panel de resultados.](0-5.png)

~~What the loop does is count from 1 to 10 (including 1 and 10), assigns that number to the constant `i`, then runs the block of code inside the braces.~~

Lo que hace el ciclo es contar desde 1 a 10 (incluyendo 1 y 10), asigna ese número a la constante `i`, entonces ejecuta el bloque de código entre los corchetes.

~~If you don't need to know what number you're on, you can use an underscore instead. For example, we could print some Taylor Swift lyrics like this:~~

Si no es necesario que sabes en qúe número estás, puedes usar un guión bayo en lugar de un nombre. Por ejemplo, podemos imprimir unas líricas de Taylor Swift así:

    var str = "Fakers gonna"

    for _ in 1 ... 5 {
        str += " fake"
    }

    print(str)

~~That will print "Fakers gonna fake fake fake fake fake" by adding to the string each time the loop goes around.~~

Eso mostrará "Fakers gonna fake fake fake fake fake" por añándolo a la cadena de caracteres durante cada iteración del ciclo.

~~If Swift doesn’t have to assign each number to a variable each time the loop goes around, it can run your code a little faster. As a result, if you write `for i in…` then don’t use `i`, Xcode will suggest you change it to `_`.~~

Si Swift no tenga que asignar cada número a un variable en cada iteración, puede ejectuar tu código un poco más rápido. Como resultado, si escribas `for i in...` entonces no usabas `i`, Xcode sugerirá que lo cambies a `_`.

Hay una especie del operador de serie cerrado que solamente usa la mitad de la serie llamado operator de serie medio abierto, y es fácil confusar los dos. La de serie medio abierto mira como `..<` y cuenta desde un número hasta y *excluyendo* otro. Por ejemplo, `1 ..< 5` contará 1, 2, 3, 4.

## Ciclando por arreglos

Swift te da un método simple para ciclar entre todos los elementos de un arreglo. Porque Swift ya sabe que tipo de dato almacenas en tu arreglo, ciclará cada elemento en el arreglo, asignará a una constante que digas, entonces ejecutará un bloque de tu código. Por ejemplo, podemos imprimir una lista de canciónes buenas así:

    var songs = ["Shake it Off", "You Belong with Me", "Look What You Made Me Do"]

    for song in songs {
        print("My favorite song is \(song)")
    }

También puedes utilizar `for i in` constructo de ciclo para ciclar entre arreglos, porque puedes utilizar esta constante para indexar en un arreglo. También podemos utilizarlo para indexar en dos arreglos, así:

    var people = ["players", "haters", "heart-breakers", "fakers"]
    var actions = ["play", "hate", "break", "fake"]

    for i in 0 ... 3 {
        print("\(people[i]) gonna \(actions[i])")
    }

`You might wonder what use the half open range operator has, but it's particularly useful for working with arrays because they count from zero. So, rather than counting from 0 up to and including 3, we could count from 0 up to and *excluding* the number of items in an array.`

Si estás preguntándote en cuales casos sería importante usar el operator de serie medio abierto, y la respuesta es que es particularmente utíl por tareas con arreglos porque ellos empiezan al cero. Así, en vez de contar desde 0 hasta y incluyendo 3, contaremos desde 0 hasta y *excluyendo* 4, o la cuenta total de los elementos del arreglo.

**Recuerdas: los arreglos cuentan desde cero, entonces si tienen 4 elementos, el índice máximo es 3 y necesitamos utilizar el especie de ciclo que *excluye* al fin.**

Para contar la cantidad de elementos en un arreglo, utiliza `someArray.count`. Podemos escribir nuestro código así:

    var people = ["players", "haters", "heart-breakers", "fakers"]
    var actions = ["play", "hate", "break", "fake"]

    for i in 0 ..< people.count {
        print("\(people[i]) gonna \(actions[i])")
    }

## Ciclos interiores

Puedes poner ciclos entre ciclos si quieres, y más ciclos entre ciclos entre ciclos – ¡pero ten cuidado, porque podrías descubrir que ejecutes 10 millones de veces!

Podemos combinar dos ciclos de antes para crear eso:

    var people = ["players", "haters", "heart-breakers", "fakers"]
    var actions = ["play", "hate", "break", "fake"]

    for i in 0 ..< people.count {
        var str = "\(people[i]) gonna"

        for _ in 1 ... 5 {
            str += " \(actions[i])"
        }

        print(str)
    }

Eso mostrará "players gonna play play play play play", y entonces "haters gonna..." ya la entiendes.

Una nota importante: aunque los programadores han utilizado `i`, `j` y `k` traditionalmente para asignar nombres sus constantes, puedes asignarlos como quieras: `for personNumber in 0 ..< people.count` es perfectamente válido. 

## Ciclos while

Hay un tercer especie de ciclo que encontrarás, que repite un bloque de código hasta que le digas parar. Utiliza esta por cosas como ciclos de juegos cuando no tienes idea al comienzo cuando terminará el juego – está repitiendo "chequear por los toques, animar los robots, dibujar por la ventana, chequear por los toques..." y así, hasta que eventualmente el usuario toca al botón para salir el juego y volver al menú principal.

Se llaman estes ciclos `while`, y miran así:

    var counter = 0

    while true {
        print("Counter is now \(counter)")
        counter += 1

        if counter == 556 {
            break
        }
    }

Ese código ha introducido una palabra clave nueva llamado `break`. Está utilizado para salir de un ciclo `while` o `for` a un punto que decides. Sin esto, el código nunca terminará porque la condición para evaluar queda "cierta" por siempre. Sin la palabra clave `break` el ciclo ejecuta como ciclo infinito, cual es Una Cosa Mala.

Estes ciclos `while` trabajan mejor en situaciones donde hay datos desconocidos, como descargando cosas afuera del internet, leyendo afuera de un archivo como XML, buscando por inputados de usuarios, y así. Esto es porque solamente sabes cuando pares el ciclo después de que ha ejecutádolo unos veces suficientes.

Hay una otra opción en vez de `break` llamado `continue`. Mientras que salir de un ciclo se para la ejecutación inmediatamente y continua directamente después del ciclo, un ciclo que continua solamente sale de la iteración corriente – volverá al comienzo del ciclo y sigue ejecutando.

Por ejemplo, considera el código por abajo:

    var songs = ["Shake it Off", "You Belong with Me", "Look What You Made Me Do"]

    for song in songs {
        if song == "You Belong with Me" {
            continue
        }

        print("My favorite song is \(song)")
    }

Este hace ciclos por tres canciónes de Taylor Swift, pero solamente mostrará los nombres de dos. A causa de la palabra clave `continue`, cuando el ciclo trata de utilizar la canción "You Belong with Me", el programa ejecute `continue`, que significa el ciclo empiece al comienzo – sin ejecutando la llamada `print()` y sigue con "Look What You Made Me Do."
