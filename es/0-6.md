<<<<<<< HEAD
# Arreglos

Los arreglos permiten agrupar muchos valores en una colección simple, para después acceder a estos utilizando su posición dentro de la colección. Swift usa inferencia de tipo para saber qué tipo de datos los contiene el arreglo, como así:
=======
# ~~Arrays~~

~~Arrays let you group lots of values together into a single collection, then access those values by their position in the collection. Swift uses type inference to figure out what type of data your array holds, like so:~~

# Arreglos

Los arreglos le permiten agrupar muchos valores colectivamente en una collección singular, después entra en los valores por sus posiciónes en la collección. Swift usa el deducción de tipo para establecer qué tipo de datos los contiene el arreglo, como así:
>>>>>>> e313aeb... WIP: (es) Part 2 - Translating 0-6.md to Spanish

    var evenNumbers = [2, 4, 6, 8]
    var songs = ["Shake it Off", "You Belong with Me", "Back to December"]
    
Como puedes ver, Swift usa corchetes para indicar el comienzo y el fin de un arreglo, y cada elemento en el arreglo se separa con una coma.

<<<<<<< HEAD
Cuando se trata de leer elementos fuera de un arreglo, hay una excepción: Swift empieza a contar en 0. Esto significa que el primer elemento es 0, el segundo elemento es 1, el tercer elemento es 2, y así. Trata de poner esto en tu playground:
=======
~~As you can see, Swift uses brackets to mark the start and end of an array, and each item in the array is separated with a comma.~~

Cómo puede ver, Swift usa los corchetes para significar el comienzo y el fín de un arreglo, y cada dato en el arreglo se separa con una coma.

~~When it comes to reading items out an array, there's a catch: Swift starts counting at 0. This means the first item is 0, the second item is 1, the third is 2, and so on. Try putting this into your playground:~~

Cuando se trata de leer datos fuera de un arreglo, hay un excepcción: Swift empieza a contar en 0. Esto significa que el primer dato es 0, el segundo dato es 1, el tercero dato es 2, y demás. Trate de poner esto en su playground:
>>>>>>> e313aeb... WIP: (es) Part 2 - Translating 0-6.md to Spanish

    var songs = ["Shake it Off", "You Belong with Me", "Back to December"]
    songs[0]
    songs[1]
    songs[2]

<<<<<<< HEAD
Eso mostrará "Shake it Off", "You Belong with Me", y "Back to December" en el panel de resultados.

La posición de un elemento del arreglo se llama índice, y puedes leer cualquier elemento del arreglo utilizándolo. Sin embargo, ten cuidado: nuestro arreglo contiene tres elementos, que significa los índices 0, 1, y 2 funcionan excelentes. Pero, si tratas de leer `songs[3]`, su playground no funcionará - ¡y si haces eso en una aplicación real va a fallar!

Ya que has creado el arreglo utilizando 3 cadenas de caracteres (Strings), Swift entiende que esto es un arreglo de cadenas de caracteres. Puedes confirmar esto utilizando el comando que, en el playground, muéstrate el tipo de datos de un variable, de esta forma:
=======
~~That will print "Shake it Off", "You Belong with Me", and "Back to December" in the results pane.~~

Eso imprimiere "Shake it Off", "You Belong with Me", and "Back to December" en el panel gráfico.

~~An item's position in an array is called its index, and you can read any item from the array just by providing its index. However, you do need to be careful: our array has three items in, which means indexes 0, 1 and 2 work great. But if you try and read `songs[3]` your playground will stop working – and if you tried that in a real app it would crash!~~

Se llama la posición de un dato en un arreglo su índice, y puede leer cada dato afuera del arreglo simplemente por proveer su índice. Sin embargo, tenga cuidado: nuestro arreglo contiene tres datos, que significa los índices 0, 1, y 2 funcionan excelentes. Pero, si usted trata de leer `songs[3]`, su playground no funcionará - ¡y si trata eso en un aplicación real va a colgarlo!

~~Because you've created your array by giving it three strings, Swift knows this is an array of strings. You can confirm this by using a special command in the playground that will print out the data type of any variable, like this:~~

A causa de que ha creado su arreglo por darlo tres cadenas de carácteres, Swift entiende que esto es un arreglo de cadenas de carácteres. Puede confirmar esto por usar un comando en el playground que imprimiere el tipo de dato de cualquier variable, como así:
>>>>>>> e313aeb... WIP: (es) Part 2 - Translating 0-6.md to Spanish

    var songs = ["Shake it Off", "You Belong with Me", "Back to December"]
    type(of: songs)

<<<<<<< HEAD
Eso mostrará `Array<String>.Type` en el panel de resultados, diciendo que Swift se considera `songs` ser un arreglo de cadenas de caracteres.

Digamos que cometes un error y, de forma accidental, insertas un número al final del arreglo. Escribe lo siguiente y observa lo que muestra el panel de resultados:
=======
~~That will print `Array<String>.Type` into the results pane, telling you that Swift considers `songs` to be an array of strings.~~

Eso imprimiere `Array<String>.Type` en el panel gráfico, diciendo a usted que Swift se considera `songs` ser un arreglo de cadenas de carácteres.

~~Let's say you made a mistake, and accidentally put a number on the end of the array. Try this now and see what the results pane prints:~~
>>>>>>> e313aeb... WIP: (es) Part 2 - Translating 0-6.md to Spanish

    var songs = ["Shake it Off", "You Belong with Me", "Back to December", 3]
    type(of: songs)

<<<<<<< HEAD
En este momento, verás un error. Este error no es causado porque Swift no puede manejar arreglos mezclados como este - ¡Te voy a enseñar esto en un momento! - más bien es porque Swift está ayudándonos. El mensaje del error que verás es, "heterogenous collection literal could only be inferred to '[Any]'; add explicit type annotation if this is intentional." Lo que quiere decir Swift es "Parece que este arreglo está diseñado para almacenar muchos tipos de datos - si realmente significa eso, por favor déjalo explícito."
=======
~~This time you'll see an error. The error isn’t because Swift can’t handle mixed arrays like this one – I’ll show you how to do that in just a moment! – but instead because Swift is being helpful. The error message you’ll see is, “heterogenous collection literal could only be inferred to '[Any]'; add explicit type annotation if this is intentional.” Or, in plain English, “it looks like this array is designed to hold lots of types of data – if you really meant that, please make it explicit.”~~

En este momento, verá un error. El error no es por causa de que Swift no puede manejar arreglos mezclados como esto - ¡Le voy a mostrar cómo hacerlo en un momento! - pero en cambio porque Swift está siendo útil. El mensaje del error que verá es, "heterogenous collection literal could only be inferred to '[Any]'; add explicit type annotation if this is intentional." Mejor dicho, "lo mira como este arreglo es designado por contener muchos tipos de datos - si realmente significa eso, por favor cambiar en algo explícito."
>>>>>>> e313aeb... WIP: (es) Part 2 - Translating 0-6.md to Spanish

**Type safety** es importante, y aunque es genial que Swift puedes iniciar arreglos que contienen cualquier tipo de dato, este caso en particular fue un accidente. Afortunadamente, he dicho antes que puedes usar especificación de tipo para decir exactamente que tipo de dato quieres almacenar en el arreglo. Utilizando corchetes se refiere a que en algún momento habrá un arreglo, y en este caso el arrelgo almacenará cadenas de caracteres:

    var songs: [String] = ["Shake it Off", "You Belong with Me", "Back to December", 3]

Ahora que hemos dicho a Swift que queremos poner solamente cadenas de caracteres en el arreglo, siempre va a negarse de ejecutar el código a causa de que 3 no es una cadena de caracteres.

Si realmente querías que el arreglo pueda almacenar cualquier tipo de dato, utiliza el tipo de dato especial `Any` así:

    var songs: [Any] = ["Shake it Off", "You Belong with Me", "Back to December", 3]

## Creando los arreglos

Si declaras un arreglo de la forma mostrada arriba, Swift creará el arreglo y almacenará los valores que hemos especificado. Las cosas no son tan simples si queremos crear un arreglo para llenarlo luego - este sintaxis no funciona:

    var songs: [String]
    songs[0] = "Shake it Off"

Al principio, la razón es algo que aparece un poco quisquillosa o pedante, pero tiene implicaciones importantes en la ejecución de la aplicación, pues lo siento pero tienes que vivir con ello. Mejor dicho, cuando escribe `var songs: [String]` está diciendo a Swift "el variable `songs` va a contener un arreglo de cadena de caracteres," pero *esto no crea el arreglo*. Esto no asigna ninguna memoria de acceso aleatorio (RAM), ni hace cualquier trabajo para iniciar o crear un arreglo de Swift.

Hay pocas maneras de expresar esto correctamente, y la que tiene más sentido por ahora es esta: 

    var songs: [String] = []

Eso tiene una anotación de tipo para clarificar que queremos un arreglo de cadenas de caracteres, y lo asigna a un arreglo vacío (eso es el `[]` parte).

También verás frecuentemente este constructor:

    var songs = [String]()

Eso significa lo mismo que la otra forma: el `()` dice a Swift que queremos iniciar un arreglo y asignarlo a `songs` gracias a la inferencia de tipo. ¡Este opción tiene dos caracteres menos, así que no es una sorpresa que lo prefieran muchos programadores!

## Operaciones de arreglos

Puedes utilizar un conjunto limitado de operadores sobre los arreglos. Por ejemplo, puedes combinar dos arreglos utilizando el operador `+`, así:

    var songs = ["Shake it Off", "You Belong with Me", "Love Story"]
    var songs2 = ["Today was a Fairytale", "Welcome to New York", "Fifteen"]
    var both = songs + songs2

También puedes usar `+=` para añadir y asignar, así:

    both += ["Everything has Changed"]
