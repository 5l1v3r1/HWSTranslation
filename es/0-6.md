# ~~Arrays~~

~~Arrays let you group lots of values together into a single collection, then access those values by their position in the collection. Swift uses type inference to figure out what type of data your array holds, like so:~~

# Arreglos

Los arreglos le permiten agrupar muchos valores colectivamente en una collección singular, después entra en los valores por sus posiciónes en la collección. Swift usa el deducción de tipo para establecer qué tipo de datos los contiene el arreglo, como así:

    var evenNumbers = [2, 4, 6, 8]
    var songs = ["Shake it Off", "You Belong with Me", "Back to December"]

~~As you can see, Swift uses brackets to mark the start and end of an array, and each item in the array is separated with a comma.~~

Cómo puede ver, Swift usa los corchetes para significar el comienzo y el fín de un arreglo, y cada dato en el arreglo se separa con una coma.

~~When it comes to reading items out an array, there's a catch: Swift starts counting at 0. This means the first item is 0, the second item is 1, the third is 2, and so on. Try putting this into your playground:~~

Cuando se trata de leer datos fuera de un arreglo, hay un excepcción: Swift empieza a contar en 0. Esto significa que el primer dato es 0, el segundo dato es 1, el tercero dato es 2, y demás. Trate de poner esto en su playground:

    var songs = ["Shake it Off", "You Belong with Me", "Back to December"]
    songs[0]
    songs[1]
    songs[2]

~~That will print "Shake it Off", "You Belong with Me", and "Back to December" in the results pane.~~

Eso imprimiere "Shake it Off", "You Belong with Me", and "Back to December" en el panel gráfico.

~~An item's position in an array is called its index, and you can read any item from the array just by providing its index. However, you do need to be careful: our array has three items in, which means indexes 0, 1 and 2 work great. But if you try and read `songs[3]` your playground will stop working – and if you tried that in a real app it would crash!~~

Se llama la posición de un dato en un arreglo su índice, y puede leer cada dato afuera del arreglo simplemente por proveer su índice. Sin embargo, tenga cuidado: nuestro arreglo contiene tres datos, que significa los índices 0, 1, y 2 funcionan excelentes. Pero, si usted trata de leer `songs[3]`, su playground no funcionará - ¡y si trata eso en un aplicación real va a colgarlo!

~~Because you've created your array by giving it three strings, Swift knows this is an array of strings. You can confirm this by using a special command in the playground that will print out the data type of any variable, like this:~~

A causa de que ha creado su arreglo por darlo tres cadenas de carácteres, Swift entiende que esto es un arreglo de cadenas de carácteres. Puede confirmar esto por usar un comando en el playground que imprimiere el tipo de dato de cualquier variable, como así:

    var songs = ["Shake it Off", "You Belong with Me", "Back to December"]
    type(of: songs)

~~That will print `Array<String>.Type` into the results pane, telling you that Swift considers `songs` to be an array of strings.~~

Eso imprimiere `Array<String>.Type` en el panel gráfico, diciendo a usted que Swift se considera `songs` ser un arreglo de cadenas de carácteres.

~~Let's say you made a mistake, and accidentally put a number on the end of the array. Try this now and see what the results pane prints:~~

    var songs = ["Shake it Off", "You Belong with Me", "Back to December", 3]
    type(of: songs)

~~This time you'll see an error. The error isn’t because Swift can’t handle mixed arrays like this one – I’ll show you how to do that in just a moment! – but instead because Swift is being helpful. The error message you’ll see is, “heterogenous collection literal could only be inferred to '[Any]'; add explicit type annotation if this is intentional.” Or, in plain English, “it looks like this array is designed to hold lots of types of data – if you really meant that, please make it explicit.”~~

En este momento, verá un error. El error no es por causa de que Swift no puede manejar arreglos mezclados como esto - ¡Le voy a mostrar cómo hacerlo en un momento! - pero en cambio porque Swift está siendo útil. El mensaje del error que verá es, "heterogenous collection literal could only be inferred to '[Any]'; add explicit type annotation if this is intentional." Mejor dicho, "lo mira como este arreglo es designado por contener muchos tipos de datos - si realmente significa eso, por favor cambiar en algo explícito."

~~Type safety is important, and although it's neat that Swift can make arrays hold any kind of data this particular case was an accident. Fortunately, I've already said that you can use type annotations to specify exactly what type of data you want an array to store. To specify the type of an array, write the data type you want to store with brackets around it, like this:~~

La seguridad de tipo es importante, y aunque es genial que Swift puede iniciar arreglos que contienen cualquier tipo de dato, este caso en particular fuera un accidente. Afortunadamente, he dicho antes que puede usar anotaciónes de tipo para decir exactamente que tipo de dato quiere contener en el arreglo. Para decir el tipo del arreglo, escriba el tipo de dato quiere contener entre corchetes, como así:

    var songs: [String] = ["Shake it Off", "You Belong with Me", "Back to December", 3]

~~Now that we've told Swift we want to store only strings in the array, it will always refuse to run the code because 3 is not a string.~~

Ahora que hemos dicho a Swift que queremos poner solamente cadenas de carácteres en el arreglo, siempre va a negarse de ejecutar el código a causa de que 3 no es un cadena de carácteres.

~~If you really want the array to hold any kind of data, use the special `Any` data type, like this:~~

Si es necesario que el arreglo contiene cualquier tipo de dato, úsese el tipo de dato especial `Any` como así:

    var songs: [Any] = ["Shake it Off", "You Belong with Me", "Back to December", 3]

## Creando los arreglos

## ~~Creating arrays~~

~~If you make an array using the syntax shown above, Swift creates the array and fills it with the values we specified. Things aren't quite so straightforward if you want to create the array then fill it later – this syntax doesn't work:~~

Si haría un arreglo con la sintaxis por arriba, Swift cree el arreglo y ponga con los valores que nos habíamos dicho. Cosas no son tan simple si quería crear el arreglo y llenarlo después - este sintaxis no funcionaría:

    var songs: [String]
    songs[0] = "Shake it Off"

~~The reason is one that will seem needlessly pedantic at first, but has deep underlying performance implications so I'm afraid you're just stuck with it. Put simply, writing `var songs: [String]` tells Swift "the `songs` variable will hold an array of strings," but *it doesn't actually create that array*. It doesn't allocate any RAM, or do any of the work to actually create a Swift array. It just says that at some point there will be an array, and it will hold strings.~~

La razón es algo que aparece un poco quisquilloso al primero, pero tiene profundo implicaciones en la ejecución subyacente de la aplicación pues lo siento pero se lo queda pegado. Mejor dicho, cuando escribe `var songs: [String]` está diciendo a Swift "el variable `songs` va a contener un arreglo de cadena de carácteres," pero *esto no se inicia el arreglo*. Esto no asigna ninguna memoria de acceso aleatorio (RAM), ni hace cualquier trabajo para iniciar o crear un arreglo de Swift.

~~There are a few ways to express this correctly, and the one that probably makes most sense at this time is this:~~

Hay unas pocas maneras para expresar esto correctamente, y la una que tiene más sentido desde ahora es esto: 

    var songs: [String] = []

~~That uses a type annotation to make it clear we want an array of strings, and it assigns an empty array (that's the `[]` part) to it.~~

Eso tiene una anotación de tipo para clarificar que queremos un arreglo de cadenas de carácteres, y lo asigna a un arreglo vacío (eso es el `[]` parte).

~~You'll also commonly see this construct:~~

También va a ver este construcción frequentemente:

    var songs = [String]()

~~That means the same thing: the `()` tells Swift we want to create the array in question, which is then assigned to `songs` using type inference. This option is two characters shorter, so it's no surprise programmers prefer it!~~

Eso significa lo mismo que la otra forma: el `()` dice a Swift que queremos iniciar un arreglo y asignarlo a `songs` con la asistancia de deducción de tipo. ¡Este opción tiene dos carácteres menos, así que pues no es una sorpresa que lo prefieren muchos programadores!

## ~~Array operators~~

## Operaciones de arreglos

~~You can use a limited set of operators on arrays. For example, you can merge two arrays by using the + operator, like this:~~

Puede poner unos pocos operadores en arreglos. Por ejemplo, puede combinar dos arreglos por usando el operador `+`, como así:

    var songs = ["Shake it Off", "You Belong with Me", "Love Story"]
    var songs2 = ["Today was a Fairytale", "Welcome to New York", "Fifteen"]
    var both = songs + songs2

~~You can also use += to add and assign, like this:~~

También puede usar `+=` para añadir y asignar, como así:

    both += ["Everything has Changed"]
