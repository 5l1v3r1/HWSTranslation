# Clases

Swift tiene otra forma de construir tipos de datos complejos llamada clases. Estas son similares a las estructuras, pero tienen diferencias importantes, incluyendo:

-   No tienes un constructor automático para inicializar tus clases; debes crear el tuyo propio.
-   Puedes definir una nueva clase basada en otra clase, añadiendo cualquier cosa nueva que desees.
-   Cuando creas una instancia de una clase, el resultado se llama objeto. Si copias ese objeto, ambas copias apuntan a los mismos datos de forma predeterminada - si cambias una, la copia cambia también.

Estas tres son las grandes diferencias, así que las trataré antes de continuar.


## Inicializando un objeto

Si queremos convertir nuestra estructura `Person` en una clase `Person`, Swift no nos dejará escribir esto:

    class Person {
        var clothes: String
        var shoes: String
    }

Esto es debido a que estamos declarando dos atributos para ser `String`, que si recuerdas deben tener un valor obligatoriamente. Esto funcionaba en la estructura porque Swift de forma automática genera un constructor para nosotros que nos obligaba a asignar un valor a ambos, pero esto no ocurre con las clases, luego Swift no puede asegurarse de que vayamos a dar los valores.

Estas son tres posibles soluciones: hacer los dos valores opcionales, darlos valores predeterminados, o crear nuestro propio constructor. La primera opción es "fea" ya que introduce opcionales en todo el código que no es necesario que estén. La segunda opción funciona, pero es poco eficiente a no ser que utilizases los valores predeterminados. Por tanto, la opción adecuada es la tercera: crear tu propio constructor.

Para hacer esto, crea un método dentro de la clase llamado `init()` que tome los dos parámetros por los que nos estamos preocupando: 

    class Person {
        var clothes: String
        var shoes: String

        init(clothes: String, shoes: String) {
            self.clothes = clothes
            self.shoes = shoes
        }
    }

Hay dos cosas que podrían llamarte la atención en este código.

Primero, no tienes que escribir `func` antes del método `init()` ya que este es especial. Segundo, debido a que los nombres de los parámetros pasados son los mismos que los nombres de los atributos que queremos asignar, debemos utilizar `self.` para aclararlo - "la propiedad `clothes` de este objeto debe ser asignada con el valor del parámetro `clothes` que recibe". Puedes darles nombres únicos si quieres, es tu decisión.

**Importante:** Swift requiere que todos los atributos no opcionales tengan un valor al final del constructor, o antes de la llamada a cualquier otro método - lo que primero ocurra.


## Herencia de clases

The second difference between classes and structs are that classes can build on each other to produce greater things, known as *class inheritance*. This is a technique used extensively in Cocoa Touch, even in the most basic programs, so it's something you should get to grips with.

Let's start with something simple: a `Singer` class that has properties, which is their name and age. As for methods, there will be a simple initializer to handle setting the properties, plus a `sing()` method that outputs some words:

    class Singer {
        var name: String
        var age: Int

        init(name: String, age: Int) {
            self.name = name
            self.age = age
        }

        func sing() {
            print("La la la la")
        }
    }

We can now create an instance of that object by calling that initializer, then read out its properties and call its method:

    var taylor = Singer(name: "Taylor", age: 25)
    taylor.name
    taylor.age
    taylor.sing()

That's our basic class, but we're going to build on it: I want to define a `CountrySinger` class that has everything the `Singer` class does, but when I call `sing()` on it I want to print "Trucks, guitars, and liquor" instead.

You could of course just copy and paste the original `Singer` into a new class called `CountrySinger` but that's a lazy way to program and it will come back to haunt you if you make later changes to `Singer` and forget to copy them across. Instead, Swift has a smarter solution: we can define `CountrySinger` as being based off `Singer` and it will get all its properties and methods for us to build on:

    class CountrySinger: Singer {

    }

That colon is what does the magic: it means "`CountrySinger` extends `Singer`." Now, that new `CountrySinger` class (called a subclass) doesn't add anything to `Singer` (called the parent class, or superclass) yet. We want it to have its own `sing()` method, but in Swift you need to learn a new keyword: `override`. This means "I know this method was implemented by my parent class, but I want to change it for this subclass."

Having the `override` keyword is helpful, because it makes your intent clear. It also allows Swift to check your code: if you don't use `override` Swift won't let you change a method you got from your superclass, or if you use `override` and there wasn't anything to override, Swift will point out your error.

So, we need to use `override func`, like this:

    class CountrySinger: Singer {
        override func sing() {
            print("Trucks, guitars, and liquor")
        }
    }

Now modify the way the `taylor` object is created:

    var taylor = CountrySinger(name: "Taylor", age: 25)
    taylor.sing()

If you change `CountrySinger` to just `Singer` you should be able to see the different messages appearing in the results pane.

Now, to make things more complicated, we're going to define a new class called `HeavyMetalSinger`. But this time we're going to store a new property called `noiseLevel` defining how loud this particular heavy metal singer likes to scream down their microphone.

This causes a problem, and it's one that needs to be solved in a very particular way:

- Swift wants all non-optional properties to have a value.
- Our `Singer` class doesn't have a `noiseLevel` property.
- So, we need to create a custom initializer for `HeavyMetalSinger` that accepts a noise level.
- That new initializer also needs to know the `name` and `age` of the heavy metal singer, so it can pass it onto the superclass `Singer`.
- Passing on data to the superclass is done through a method call, and you can't make method calls in initializers until you have given all your properties values.
- So, we need to set our own property first (`noiseLevel`) then pass on the other parameters for the superclass to use.

That might sound awfully complicated, but in code it's straightforward. Here's the `HeavyMetalSinger` class, complete with its own `sing()` method:

    class HeavyMetalSinger: Singer {
        var noiseLevel: Int

        init(name: String, age: Int, noiseLevel: Int) {
            self.noiseLevel = noiseLevel
            super.init(name: name, age: age)
        }

        override func sing() {
            print("Grrrrr rargh rargh rarrrrgh!")
        }
    }

Notice how its initializer takes three parameters, then calls `super.init()` to pass `name` and `age` on to the `Singer` superclass - but only after its own property has been set. You'll see `super` used a lot when working with objects, and it just means "call a method on the class I inherited from.” It's usually used to mean "let my parent class do everything it needs to do first, then I'll do my extra bits."

Class inheritance is a big topic so don't fret if it's not clear just yet. However, there is one more thing you need to know: class inheritance often spans many levels. For example, A could inherit from B, and B could inherit from C, and C could inherit from D, and so on. This lets you build functionality and re-use up over a number of classes, helping to keep your code modular and easy to understand.


## Trabajando con código de Objective-C

Si quieres que parte del sistema operativo de Apple llame al método de tu clase de Swift, debes marcarlo con un atributo especial: `@objc`. Es la abriviatura de "Objective-C", y el atributo marca de forma efectiva como disponible para ejecutarse con código del antiguo Objective-C, que es casi todo de iOS, macOS, watchOS, y tvOS. Por ejemplo, si pides al sistema que llame a tu método después de que haya transcurrido un segundo, deberás marcarlo con `@objc`.

Por ahora no te preocupes mucho sobre `@objc`, no solo lo explicaré en el contexto más adelante, sino que Xcode siempre te dirá cuando es necesario. Alternativamente, si no quieres usar `@objc` para métodos individuales, puedes poner `@objcMembers` antes de tu clase para automáticamente hacer todos tus métodos disponibles para Objective-C.


## Valores vs Referencias

When you copy a struct, the whole thing is duplicated, including all its values. This means that changing one copy of a struct doesn't change the other copies – they are all individual. With classes, each copy of an object points at the same original object, so if you change one they all change. Swift calls structs "value types" because they just point at a value, and classes "reference types" because objects are just shared references to the real value.

This is an important difference, and it means the choice between structs and classes is an important one:

-   If you want to have one shared state that gets passed around and modified in place, you're looking for classes. You can pass them into functions or store them in arrays, modify them in there, and have that change reflected in the rest of your program.
-   If you want to avoid shared state where one copy can't affect all the others, you're looking for structs. You can pass them into functions or store them in arrays, modify them in there, and they won't change wherever else they are referenced.

If I were to summarize this key difference between structs and classes, I'd say this: classes offer more flexibility, whereas structs offer more safety. As a basic rule, you should always use structs until you have a specific reason to use classes.
